# TOAST config
# Generated with version f963f420

[operators.load_hdf5]
    class = "toast.ops.load_hdf5.LoadHDF5"
    API = 0 # Internal interface version for this operator
    detdata = "[]" # Only load this list of detdata objects
    enabled = false # If True, this class instance is marked as enabled
    files = "[]" # Override `volume` and load a list of files
    force_serial = false # Use serial HDF5 operations, even if parallel support available
    intervals = "[]" # Only load this list of intervals objects
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    meta = "[]" # Only load this list of meta objects
    name = "load_hdf5" # The 'name' of this class instance
    pattern = "obs_.*_.*\\.h5" # Regexp pattern to match files against
    process_rows = "None" # The size of the rectangular process grid in the detector direction.
    shared = "[]" # Only load this list of shared objects
    sort_by_size = false # If True, sort observations by size before load balancing
    volume = "None" # Top-level directory containing the data volume

[operators.load_books]
    class = "sotodlib.toast.ops.load_books.LoadBooks"
    API = 0 # Internal interface version for this operator
    azimuth = "azimuth" # Observation shared key for boresight Azimuth
    bands = "[]" # Only load detectors from these bands
    books = "[]" # List of observation book directories
    boresight_angle = "boresight_angle" # Observation shared key for boresight rotation angle (if it is used)
    boresight_azel = "boresight_azel" # Observation shared key for boresight Az/El quaternions
    boresight_radec = "boresight_radec" # Observation shared key for boresight RA/DEC quaternions
    corotator_angle = "corotator_angle" # Observation shared key for corotator_angle (if it is used)
    det_data = "signal" # Observation detdata key for detector signal
    det_flags = "flags" # Observation detdata key for detector flags
    detset_key = "None" # If specified, use this column of the focalplane detector_data to group detectors
    elevation = "elevation" # Observation shared key for boresight Elevation
    enabled = false # If True, this class instance is marked as enabled
    focalplane_dir = "None" # Directory for focalplane models
    frame_intervals = "None" # Observation interval key for frame boundaries
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "load_books" # The 'name' of this class instance
    noise_dir = "None" # Directory for noise models
    shared_flags = "flags" # Observation shared key for common flags
    times = "times" # Observation shared key for timestamps
    wafers = "[]" # Only load detectors from these wafers / stream_ids

[operators.load_context]
    class = "sotodlib.toast.ops.load_context.LoadContext"
    API = 0 # Internal interface version for this operator
    analytic_bandpass = false # Add analytic bandpass to each detector
    ax_boresight_az = "boresight:az" # Field with boresight Az
    ax_boresight_el = "boresight:el" # Field with boresight El
    ax_boresight_roll = "boresight:roll" # Field with boresight Roll
    ax_det_flags = "[]" # Tuples of (field, bit_value) merged to det_flags
    ax_det_signal = "signal" # Name of field to associate with det_data
    ax_detinfo_wafer_key = "stream_id" # Name of the det_info property containing the wafer ID
    ax_flags = "[]" # Tuples of (field, bit value) merged to shared_flags
    ax_hwp_angle = "hwp_angle" # Field with HWP angle
    ax_pathsep = ":" # Path separator when flattening nested fields
    ax_times = "timestamps" # Name of field to associate with times
    axis_detector = "dets" # Name of the LabelAxis for the detector direction
    axis_sample = "samps" # Name of the OffsetAxis for the sample direction
    azimuth = "azimuth" # Observation shared key for boresight Azimuth
    bands = "[]" # Only load this list of band values
    bandwidth = 0.2 # Fractional bandwith used in analytic bandpass
    boresight_angle = "None" # Observation shared key for boresight rotation angle (if it is used)
    boresight_azel = "boresight_azel" # Observation shared key for boresight Az/El quaternions
    boresight_radec = "boresight_radec" # Observation shared key for boresight RA/DEC quaternions
    combine_wafers = false # If True, combine all wafers into a single observation
    context = "None" # The Context, which should exist on all processes
    context_file = "None" # Create a context from this file
    corotator_angle = "None" # Observation shared key for corotator_angle (if it is used)
    det_data = "signal" # Observation detdata key for detector signal
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flags = "flags" # Observation detdata key for detector flags
    dets_select = "{}" # The `dets` selection dictionary to pass to get_obs()
    detset_key = "None" # Column of the focalplane detector_data to use for data distribution
    detsets = "[]" # Only load this list of detset values
    elevation = "elevation" # Observation shared key for boresight Elevation
    enabled = false # If True, this class instance is marked as enabled
    hwp_angle = "None" # Observation shared key for HWP angle (if it is used)
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "load_context" # The 'name' of this class instance
    observation_file = "None" # Text file containing observation IDs to load
    observation_regex = "None" # Regular expression match to apply to observation IDs
    observations = "[]" # List of observation IDs to load
    preprocess_config = "None" # Apply pre-processing with this configuration
    readout_ids = "[]" # Only load this list of readout_id values
    roll = "roll" # Observation shared key for boresight Roll
    shared_flags = "flags" # Observation shared key for common flags
    telescope_name = "UNKNOWN" # Name of the telescope
    times = "times" # Observation shared key for timestamps

[operators.sim_ground]
    class = "toast.ops.sim_ground.SimGround"
    API = 0 # Internal interface version for this operator
    azimuth = "azimuth" # Observation shared key for Azimuth
    boresight_azel = "boresight_azel" # Observation shared key for boresight AZ/EL
    boresight_radec = "boresight_radec" # Observation shared key for boresight RA/DEC
    det_data = "signal" # Observation detdata key to initialize
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flags = "flags" # Observation detdata key for flags to initialize
    detset_key = "pixel" # If specified, use this column of the focalplane detector_data to group detectors
    distribute_time = false # Distribute observation data along the time axis rather than detector axis
    el_mod_amplitude = "Quantity('1.00000000000000e+00 deg')" # Range of elevation modulation
    el_mod_rate = "Quantity('0.00000000000000e+00 Hz')" # Modulate elevation continuously at this rate
    el_mod_sine = false # Modulate elevation with a sine wave instead of a triangle wave
    el_mod_step = "Quantity('0.00000000000000e+00 deg')" # Amount to step elevation after each left-right scan pair
    elevation = "elevation" # Observation shared key for Elevation
    elnod_end = false # Perform an el-nod after the scan
    elnod_every_scan = false # Perform el nods every scan
    elnod_interval = "elnod" # Interval name for elnods
    elnod_mask = 8 # Bit mask to raise elevation nod flags with
    elnod_start = false # Perform an el-nod before the scan
    elnods = "[]" # List of relative el_nods
    enabled = false # If True, this class instance is marked as enabled
    fix_rate_on_sky = true # If True, `scan_rate_az` is given in sky coordinates and azimuthal rate on mount will be adjusted to meet it.  If False, `scan_rate_az` is used as the mount azimuthal rate.
    hwp_angle = "None" # Observation shared key for HWP angle
    hwp_rpm = "None" # The rate (in RPM) of the HWP rotation
    hwp_step = "None" # For stepped HWP, the angle of each step
    hwp_step_time = "None" # For stepped HWP, the time between steps
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    max_pwv = "None" # Maximum PWV for the simulated weather.
    median_weather = false # Use median weather parameters instead of sampling from the distributions
    name = "sim_ground" # The 'name' of this class instance
    position = "position" # Observation shared key for position
    randomize_phase = false # If True, the Constant Elevation Scan will begin at a randomized phase.
    realization = 0 # The realization index
    scan_accel_az = "Quantity('1.00000000000000e+00 deg / s2')" # Mount scanning rate acceleration for turnarounds
    scan_accel_el = "Quantity('1.00000000000000e+00 deg / s2')" # Mount elevation rate acceleration.
    scan_cosecant_modulation = false # Modulate the scan rate according to 1/sin(az) for uniform depth
    scan_leftright_interval = "scan_leftright" # Interval name for left to right scans
    scan_rate_az = "Quantity('1.00000000000000e+00 deg / s')" # The sky or mount azimuth scanning rate.  See `fix_rate_on_sky`
    scan_rate_el = "Quantity('1.00000000000000e+00 deg / s')" # The sky elevation scanning rate
    scan_rightleft_interval = "scan_rightleft" # Interval name for right to left scans
    scanning_interval = "scanning" # Interval name for scanning
    schedule = "None" # Instance of a GroundSchedule
    session_split_key = "wafer_slot" # Focalplane key for splitting into observations
    shared_flags = "flags" # Observation shared key for common flags
    sun_angle_min = "Quantity('9.00000000000000e+01 deg')" # Minimum angular distance for the scan and the Sun
    sun_close_distance = "Quantity('4.50000000000000e+01 deg')" # 'Sun close' flagging distance
    sun_close_interval = "sun_close" # Interval name for times when the sun is close
    sun_close_mask = 32 # Bit mask to raise Sun close flags with
    sun_up_interval = "sun_up" # Interval name for times when the sun is up
    sun_up_mask = 16 # Bit mask to raise Sun up flags with
    telescope = "None" # This must be an instance of a Telescope
    throw_interval = "throw" # Interval name for scan + turnaround intervals
    throw_leftright_interval = "throw_leftright" # Interval name for left to right scans + turnarounds
    throw_rightleft_interval = "throw_rightleft" # Interval name for right to left scans + turnarounds
    times = "times" # Observation shared key for timestamps
    track_azimuth = false # If True, the azimuth throw is continually adjusted to center the field.
    turn_leftright_interval = "turn_leftright" # Interval name for turnarounds after left to right scans
    turn_rightleft_interval = "turn_rightleft" # Interval name for turnarounds after right to left scans
    turnaround_interval = "turnaround" # Interval name for turnarounds
    turnaround_mask = 4 # Bit mask to raise turnaround flags with
    use_ephem = true # Use PyEphem to convert between horizontal and equatorial systems
    use_qpoint = false # Use qpoint to convert between horizontal and equatorial systems
    velocity = "velocity" # Observation shared key for velocity
    weather = "atacama" # Name of built-in weather site (e.g. 'atacama', 'south_pole') or path to HDF5 file

[operators.corotate_lat]
    class = "sotodlib.toast.ops.corotator.CoRotator"
    API = 0 # Internal interface version for this operator
    boresight_azel = "boresight_azel" # Observation shared key for boresight Az/El
    boresight_radec = "boresight_radec" # Observation shared key for boresight RA/Dec
    corotate_lat = true # If True, rotate LAT receiver to maintain projected focalplane orientation
    corotator_angle = "corotator_angle" # Observation shared key for corotation angle
    elevation = "elevation" # Observation shared key for boresight elevation
    enabled = true # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "corotate_lat" # The 'name' of this class instance

[operators.perturb_hwp]
    class = "toast.ops.sim_hwp.PerturbHWP"
    API = 0 # Internal interface version for this operator
    drift_sigma = "None" # 1-sigma relative change in spin rate, such as 0.01 / hour
    enabled = false # If True, this class instance is marked as enabled
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "perturb_hwp" # The 'name' of this class instance
    realization = 0 # Realization index
    time_sigma = "None" # 1-sigma difference between real and nominal time stamps
    times = "times" # Observation shared key for timestamps

[operators.det_pointing_azel_sim]
    class = "toast.ops.pointing_detector.pointing_detector.PointingDetectorSimple"
    API = 0 # Internal interface version for this operator
    boresight = "boresight_azel" # Observation shared key for boresight
    coord_in = "None" # The input boresight coordinate system ('C', 'E', 'G')
    coord_out = "None" # The output coordinate system ('C', 'E', 'G')
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    hwp_angle_offset = "Quantity('0.00000000000000e+00 deg')" # HWP angle offset to apply when constructing deflection
    hwp_deflection_radius = "None" # If non-zero, nominal detector pointing will be deflected in a circular pattern according to HWP phase.
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "det_pointing_azel_sim" # The 'name' of this class instance
    quats = "quats_azel_sim" # Observation detdata key for output quaternions
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    view = "None" # Use this view of the data in all observations

[operators.det_pointing_radec_sim]
    class = "toast.ops.pointing_detector.pointing_detector.PointingDetectorSimple"
    API = 0 # Internal interface version for this operator
    boresight = "boresight_radec" # Observation shared key for boresight
    coord_in = "None" # The input boresight coordinate system ('C', 'E', 'G')
    coord_out = "None" # The output coordinate system ('C', 'E', 'G')
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    hwp_angle_offset = "Quantity('0.00000000000000e+00 deg')" # HWP angle offset to apply when constructing deflection
    hwp_deflection_radius = "None" # If non-zero, nominal detector pointing will be deflected in a circular pattern according to HWP phase.
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "det_pointing_radec_sim" # The 'name' of this class instance
    quats = "quats_radec_sim" # Observation detdata key for output quaternions
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    view = "None" # Use this view of the data in all observations

[operators.det_pointing_azel]
    class = "toast.ops.pointing_detector.pointing_detector.PointingDetectorSimple"
    API = 0 # Internal interface version for this operator
    boresight = "boresight_radec" # Observation shared key for boresight
    coord_in = "None" # The input boresight coordinate system ('C', 'E', 'G')
    coord_out = "None" # The output coordinate system ('C', 'E', 'G')
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    hwp_angle_offset = "Quantity('0.00000000000000e+00 deg')" # HWP angle offset to apply when constructing deflection
    hwp_deflection_radius = "None" # If non-zero, nominal detector pointing will be deflected in a circular pattern according to HWP phase.
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "det_pointing_azel" # The 'name' of this class instance
    quats = "quats_azel" # Observation detdata key for output quaternions
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    view = "None" # Use this view of the data in all observations

[operators.det_pointing_radec]
    class = "toast.ops.pointing_detector.pointing_detector.PointingDetectorSimple"
    API = 0 # Internal interface version for this operator
    boresight = "boresight_radec" # Observation shared key for boresight
    coord_in = "None" # The input boresight coordinate system ('C', 'E', 'G')
    coord_out = "None" # The output coordinate system ('C', 'E', 'G')
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    hwp_angle_offset = "Quantity('0.00000000000000e+00 deg')" # HWP angle offset to apply when constructing deflection
    hwp_deflection_radius = "None" # If non-zero, nominal detector pointing will be deflected in a circular pattern according to HWP phase.
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "det_pointing_radec" # The 'name' of this class instance
    quats = "quats_radec" # Observation detdata key for output quaternions
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    view = "None" # Use this view of the data in all observations

[operators.weights_azel]
    class = "toast.ops.stokes_weights.stokes_weights.StokesWeights"
    API = 0 # Internal interface version for this operator
    IAU = false # If True, use the IAU convention rather than COSMO
    cal = "None" # The observation key with a dictionary of pointing weight calibration for each det
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = true # If True, this class instance is marked as enabled
    fp_gamma = "gamma" # Focalplane key for detector gamma offset angle
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    mode = "IQU" # The Stokes weights to generate (I or IQU)
    name = "weights_azel" # The 'name' of this class instance
    single_precision = false # If True, use 32bit float in output
    view = "None" # Use this view of the data in all observations
    weights = "weights_azel" # Observation detdata key for output weights

[operators.weights_radec]
    class = "toast.ops.stokes_weights.stokes_weights.StokesWeights"
    API = 0 # Internal interface version for this operator
    IAU = false # If True, use the IAU convention rather than COSMO
    cal = "None" # The observation key with a dictionary of pointing weight calibration for each det
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = true # If True, this class instance is marked as enabled
    fp_gamma = "gamma" # Focalplane key for detector gamma offset angle
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    mode = "IQU" # The Stokes weights to generate (I or IQU)
    name = "weights_radec" # The 'name' of this class instance
    single_precision = false # If True, use 32bit float in output
    view = "None" # Use this view of the data in all observations
    weights = "weights" # Observation detdata key for output weights

[operators.pixels_healpix_radec]
    class = "toast.ops.pixels_healpix.pixels_healpix.PixelsHealpix"
    API = 0 # Internal interface version for this operator
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = true # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_healpix_radec" # The 'name' of this class instance
    nest = true # If True, use NESTED ordering instead of RING
    nside = 64 # The NSIDE resolution
    nside_submap = 16 # The NSIDE of the submap resolution
    pixels = "pixels" # Observation detdata key for output pixel indices
    single_precision = false # If True, use 32bit int in output
    view = "None" # Use this view of the data in all observations

[operators.pixels_healpix_radec_final]
    class = "toast.ops.pixels_healpix.pixels_healpix.PixelsHealpix"
    API = 0 # Internal interface version for this operator
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_healpix_radec_final" # The 'name' of this class instance
    nest = true # If True, use NESTED ordering instead of RING
    nside = 64 # The NSIDE resolution
    nside_submap = 16 # The NSIDE of the submap resolution
    pixels = "pixels" # Observation detdata key for output pixel indices
    single_precision = false # If True, use 32bit int in output
    view = "None" # Use this view of the data in all observations

[operators.pixels_wcs_azel]
    class = "toast.ops.pixels_wcs.PixelsWCS"
    API = 0 # Internal interface version for this operator
    auto_bounds = true # If True, set the bounding box based on boresight and field of view
    bounds = "()" # The (lon_min, lon_max, lat_min, lat_max) values (Quantities)
    center = "()" # The center Lon/Lat coordinates (Quantities) of the projection
    center_offset = "None" # Optional name of shared field with lon, lat offset in degrees
    coord_frame = "EQU" # Supported values are AZEL, EQU, GAL, ECL
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dimensions = "(1000,1000,)" # The Lon/Lat pixel dimensions of the projection
    enabled = false # If True, this class instance is marked as enabled
    fits_header = "None" # FITS file containing header to use with pre-existing WCS parameters
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_wcs_azel" # The 'name' of this class instance
    pixels = "pixels" # Observation detdata key for output pixel indices
    projection = "CAR" # Supported values are CAR, CEA, MER, ZEA, TAN, SFL
    resolution = "(Quantity('5.00000000000000e-03 deg'),Quantity('5.00000000000000e-03 deg'),)" # The Lon/Lat projection resolution (Quantities) along the 2 axes
    single_precision = false # If True, use 32bit int in output
    submaps = 1 # Number of submaps to use
    use_astropy = true # If True, use astropy for world to pix conversion
    view = "None" # Use this view of the data in all observations

[operators.pixels_wcs_azel_final]
    class = "toast.ops.pixels_wcs.PixelsWCS"
    API = 0 # Internal interface version for this operator
    auto_bounds = true # If True, set the bounding box based on boresight and field of view
    bounds = "()" # The (lon_min, lon_max, lat_min, lat_max) values (Quantities)
    center = "()" # The center Lon/Lat coordinates (Quantities) of the projection
    center_offset = "None" # Optional name of shared field with lon, lat offset in degrees
    coord_frame = "EQU" # Supported values are AZEL, EQU, GAL, ECL
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dimensions = "(1000,1000,)" # The Lon/Lat pixel dimensions of the projection
    enabled = false # If True, this class instance is marked as enabled
    fits_header = "None" # FITS file containing header to use with pre-existing WCS parameters
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_wcs_azel_final" # The 'name' of this class instance
    pixels = "pixels" # Observation detdata key for output pixel indices
    projection = "CAR" # Supported values are CAR, CEA, MER, ZEA, TAN, SFL
    resolution = "()" # The Lon/Lat projection resolution (Quantities) along the 2 axes
    single_precision = false # If True, use 32bit int in output
    submaps = 1 # Number of submaps to use
    use_astropy = true # If True, use astropy for world to pix conversion
    view = "None" # Use this view of the data in all observations

[operators.pixels_wcs_radec]
    class = "toast.ops.pixels_wcs.PixelsWCS"
    API = 0 # Internal interface version for this operator
    auto_bounds = true # If True, set the bounding box based on boresight and field of view
    bounds = "()" # The (lon_min, lon_max, lat_min, lat_max) values (Quantities)
    center = "()" # The center Lon/Lat coordinates (Quantities) of the projection
    center_offset = "None" # Optional name of shared field with lon, lat offset in degrees
    coord_frame = "EQU" # Supported values are AZEL, EQU, GAL, ECL
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dimensions = "(1000,1000,)" # The Lon/Lat pixel dimensions of the projection
    enabled = false # If True, this class instance is marked as enabled
    fits_header = "None" # FITS file containing header to use with pre-existing WCS parameters
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_wcs_radec" # The 'name' of this class instance
    pixels = "pixels" # Observation detdata key for output pixel indices
    projection = "CAR" # Supported values are CAR, CEA, MER, ZEA, TAN, SFL
    resolution = "(Quantity('5.00000000000000e-03 deg'),Quantity('5.00000000000000e-03 deg'),)" # The Lon/Lat projection resolution (Quantities) along the 2 axes
    single_precision = false # If True, use 32bit int in output
    submaps = 1 # Number of submaps to use
    use_astropy = true # If True, use astropy for world to pix conversion
    view = "None" # Use this view of the data in all observations

[operators.pixels_wcs_radec_final]
    class = "toast.ops.pixels_wcs.PixelsWCS"
    API = 0 # Internal interface version for this operator
    auto_bounds = true # If True, set the bounding box based on boresight and field of view
    bounds = "()" # The (lon_min, lon_max, lat_min, lat_max) values (Quantities)
    center = "()" # The center Lon/Lat coordinates (Quantities) of the projection
    center_offset = "None" # Optional name of shared field with lon, lat offset in degrees
    coord_frame = "EQU" # Supported values are AZEL, EQU, GAL, ECL
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dimensions = "(1000,1000,)" # The Lon/Lat pixel dimensions of the projection
    enabled = false # If True, this class instance is marked as enabled
    fits_header = "None" # FITS file containing header to use with pre-existing WCS parameters
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_wcs_radec_final" # The 'name' of this class instance
    pixels = "pixels" # Observation detdata key for output pixel indices
    projection = "CAR" # Supported values are CAR, CEA, MER, ZEA, TAN, SFL
    resolution = "()" # The Lon/Lat projection resolution (Quantities) along the 2 axes
    single_precision = false # If True, use 32bit int in output
    submaps = 1 # Number of submaps to use
    use_astropy = true # If True, use astropy for world to pix conversion
    view = "None" # Use this view of the data in all observations

[operators.default_model]
    class = "toast.ops.noise_model.DefaultNoiseModel"
    API = 0 # Internal interface version for this operator
    enabled = true # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "default_model" # The 'name' of this class instance
    noise_model = "noise_model" # The observation key for storing the noise model

[operators.elevation_model]
    class = "toast.ops.elevation_noise.ElevationNoise"
    API = 0 # Internal interface version for this operator
    detector_pointing = "None" # Operator that translates boresight Az / El pointing into detector frame
    enabled = true # If True, this class instance is marked as enabled
    extra_factor = "None" # Extra multiplier to the NET scaling
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    modulate_pwv = false # If True, modulate the NET based on PWV
    name = "elevation_model" # The 'name' of this class instance
    noise_a = "None" # Parameter 'a' in (a / sin(el) + c).  If not set, look for one in the Focalplane.
    noise_c = "None" # Parameter 'c' in (a / sin(el) + c).  If not set, look for one in the Focalplane.
    noise_model = "noise_model" # The observation key containing the input noise model
    out_model = "noise_model" # Create a new noise model with this name
    pwv_a0 = "None" # Parameter 'a0' in (a0 + pwv * a1 + pwv ** 2 * a2).  If not set, look for one in the Focalplane.
    pwv_a1 = "None" # Parameter 'a1' in (a0 + pwv * a1 + pwv ** 2 * a2).  If not set, look for one in the Focalplane.
    pwv_a2 = "None" # Parameter 'a2' in (a0 + pwv * a1 + pwv ** 2 * a2).  If not set, look for one in the Focalplane.
    times = "times" # Observation shared key for timestamps
    view = "None" # Use this view of the data in all observations.  Use 'middle' if the middle 10 seconds of each observation is enough to determine the effective observing elevation

[operators.common_mode_noise]
    class = "toast.ops.common_mode_noise.CommonModeNoise"
    API = 0 # Internal interface version for this operator
    NET = "None" # 
    alpha = "None" # 
    component = 0 # The noise component index
    coupling_strength_center = 1.0 # Mean coupling strength between the detectors and the common mode
    coupling_strength_width = 0.0 # Width of the coupling strength distribution about `coupling_strength_center`
    detset = "[]" # List of detectors to add the common mode to.  Only used if `focalplane_key` is None
    enabled = false # If True, this class instance is marked as enabled
    fknee = "None" # 
    fmin = "None" # 
    focalplane_key = "None" # Detectors sharing the focalplane key will have the same common mode
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "common_mode_noise" # The 'name' of this class instance
    noise_model = "noise_model" # The observation key containing the input noise model
    out_model = "None" # Create a new noise model with this name
    realization = 0 # The noise component index
    static_coupling = false # If True, coupling to the common mode is not randomized over observations and realizations

[operators.sim_atmosphere_coarse]
    class = "toast.ops.sim_tod_atm.SimAtmosphere"
    API = 0 # Internal interface version for this operator
    add_loading = false # Add elevation-dependent loading.
    cache_dir = "None" # Directory to use for loading / saving atmosphere realizations
    cache_only = false # If True, only cache the atmosphere, do not observe it.
    component = 123456 # The component index to use for this atmosphere simulation
    corr_lim = 0.001 # Correlation limit is used to measure the correlation length of the simulation.  Elements further than correlation length apart have their covariance set to zero.
    debug_plots = false # If True, make plots of the debug snapshots
    debug_snapshots = false # If True, dump snapshots of the atmosphere slabs to pickle files
    debug_spectrum = false # If True, dump out Kolmogorov debug files
    debug_tod = false # If True, dump TOD to pickle files
    det_data = "signal" # Observation detdata key for accumulating atmosphere timestreams
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight Az/El pointing into detector frame
    detector_weights = "None" # Operator that translates boresight Az/El pointing into detector weights
    enabled = false # If True, this class instance is marked as enabled
    fade_time = "Quantity('6.00000000000000e+01 s')" # Fade in/out time to avoid a step at wind break.
    field_of_view = "None" # Override the focalplane field of view
    gain = 0.0006 # Scaling applied to the simulated TOD
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lmax_center = "Quantity('1.00000000000000e+04 m')" # Kolmogorov turbulence injection scale center
    lmax_sigma = "Quantity('1.00000000000000e+03 m')" # Kolmogorov turbulence injection scale sigma
    lmin_center = "Quantity('3.00000000000000e+02 m')" # Kolmogorov turbulence dissipation scale center
    lmin_sigma = "Quantity('3.00000000000000e+01 m')" # Kolmogorov turbulence dissipation scale sigma
    n_bandpass_freqs = 100 # The number of sampling frequencies used when convolving the bandpass with atmosphere absorption and loading
    name = "sim_atmosphere_coarse" # The 'name' of this class instance
    nelem_sim_max = 30000 # Controls the size of the simulation slices
    overwrite_cache = false # If True, redo and overwrite any cached atmospheric realizations.
    polarization_fraction = 0.0 # Polarization fraction (only Q polarization).
    realization = 1000000 # If simulating multiple realizations, the realization index
    sample_rate = "None" # Rate at which to sample atmospheric TOD before interpolation.  Default is no interpolation.
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    times = "times" # Observation shared key for timestamps
    turnaround_interval = "turnaround" # Interval name for turnarounds
    view = "None" # Use this view of the data in all observations
    wind_dist = "Quantity('1.00000000000000e+04 m')" # Maximum wind drift before discarding the volume and creating a new one
    xstep = "Quantity('5.00000000000000e+01 m')" # Size of volume elements in X direction
    ystep = "Quantity('5.00000000000000e+01 m')" # Size of volume elements in Y direction
    z0_center = "Quantity('2.00000000000000e+03 m')" # Central value of the water vapor distribution
    z0_sigma = "Quantity('0.00000000000000e+00 m')" # Sigma of the water vapor distribution
    zatm = "Quantity('4.00000000000000e+04 m')" # Atmosphere extent for temperature profile
    zmax = "Quantity('2.00000000000000e+03 m')" # Atmosphere extent for water vapor integration
    zstep = "Quantity('5.00000000000000e+01 m')" # Size of volume elements in Z direction

[operators.sim_atmosphere]
    class = "toast.ops.sim_tod_atm.SimAtmosphere"
    API = 0 # Internal interface version for this operator
    add_loading = true # Add elevation-dependent loading.
    cache_dir = "None" # Directory to use for loading / saving atmosphere realizations
    cache_only = false # If True, only cache the atmosphere, do not observe it.
    component = 123456 # The component index to use for this atmosphere simulation
    corr_lim = 0.001 # Correlation limit is used to measure the correlation length of the simulation.  Elements further than correlation length apart have their covariance set to zero.
    debug_plots = false # If True, make plots of the debug snapshots
    debug_snapshots = false # If True, dump snapshots of the atmosphere slabs to pickle files
    debug_spectrum = false # If True, dump out Kolmogorov debug files
    debug_tod = false # If True, dump TOD to pickle files
    det_data = "signal" # Observation detdata key for accumulating atmosphere timestreams
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight Az/El pointing into detector frame
    detector_weights = "None" # Operator that translates boresight Az/El pointing into detector weights
    enabled = false # If True, this class instance is marked as enabled
    fade_time = "Quantity('6.00000000000000e+01 s')" # Fade in/out time to avoid a step at wind break.
    field_of_view = "None" # Override the focalplane field of view
    gain = 4e-05 # Scaling applied to the simulated TOD
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lmax_center = "Quantity('1.00000000000000e+00 m')" # Kolmogorov turbulence injection scale center
    lmax_sigma = "Quantity('1.00000000000000e-01 m')" # Kolmogorov turbulence injection scale sigma
    lmin_center = "Quantity('1.00000000000000e-03 m')" # Kolmogorov turbulence dissipation scale center
    lmin_sigma = "Quantity('1.00000000000000e-04 m')" # Kolmogorov turbulence dissipation scale sigma
    n_bandpass_freqs = 100 # The number of sampling frequencies used when convolving the bandpass with atmosphere absorption and loading
    name = "sim_atmosphere" # The 'name' of this class instance
    nelem_sim_max = 10000 # Controls the size of the simulation slices
    overwrite_cache = false # If True, redo and overwrite any cached atmospheric realizations.
    polarization_fraction = 0.0 # Polarization fraction (only Q polarization).
    realization = 0 # If simulating multiple realizations, the realization index
    sample_rate = "None" # Rate at which to sample atmospheric TOD before interpolation.  Default is no interpolation.
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    times = "times" # Observation shared key for timestamps
    turnaround_interval = "turnaround" # Interval name for turnarounds
    view = "None" # Use this view of the data in all observations
    wind_dist = "Quantity('1.00000000000000e+03 m')" # Maximum wind drift before discarding the volume and creating a new one
    xstep = "Quantity('4.00000000000000e+00 m')" # Size of volume elements in X direction
    ystep = "Quantity('4.00000000000000e+00 m')" # Size of volume elements in Y direction
    z0_center = "Quantity('2.00000000000000e+03 m')" # Central value of the water vapor distribution
    z0_sigma = "Quantity('0.00000000000000e+00 m')" # Sigma of the water vapor distribution
    zatm = "Quantity('4.00000000000000e+04 m')" # Atmosphere extent for temperature profile
    zmax = "Quantity('2.00000000000000e+02 m')" # Atmosphere extent for water vapor integration
    zstep = "Quantity('4.00000000000000e+00 m')" # Size of volume elements in Z direction

[operators.scan_map]
    class = "toast.ops.scan_healpix.ScanHealpixMap"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key for accumulating output.  Use ';' if different files are applied to different flavors
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    file = "None" # Path to healpix FITS file.  Use ';' if providing multiple files
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "scan_map" # The 'name' of this class instance
    pixel_dist = "pixel_dist" # The Data key where the PixelDistribution object is located
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator
    save_map = false # If True, do not delete map during finalize
    save_pointing = false # If True, do not clear detector pointing matrices if we generate the pixel distribution
    stokes_weights = "None" # This must be an instance of a Stokes weights operator
    subtract = false # If True, subtract the map timestream instead of accumulating
    zero = false # If True, zero the data before accumulating / subtracting

[operators.scan_map_weights]
    class = "toast.ops.stokes_weights.stokes_weights.StokesWeights"
    API = 0 # Internal interface version for this operator
    IAU = false # If True, use the IAU convention rather than COSMO
    cal = "None" # The observation key with a dictionary of pointing weight calibration for each det
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    fp_gamma = "gamma" # Focalplane key for detector gamma offset angle
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    mode = "IQU" # The Stokes weights to generate (I or IQU)
    name = "scan_map_weights" # The 'name' of this class instance
    single_precision = false # If True, use 32bit float in output
    view = "None" # Use this view of the data in all observations
    weights = "weights_scan_map" # Observation detdata key for output weights

[operators.scan_map_pixels]
    class = "toast.ops.pixels_healpix.pixels_healpix.PixelsHealpix"
    API = 0 # Internal interface version for this operator
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "scan_map_pixels" # The 'name' of this class instance
    nest = true # If True, use NESTED ordering instead of RING
    nside = 64 # The NSIDE resolution
    nside_submap = 16 # The NSIDE of the submap resolution
    pixels = "pixels_scan_map" # Observation detdata key for output pixel indices
    single_precision = false # If True, use 32bit int in output
    view = "None" # Use this view of the data in all observations

[operators.scan_wcs_map]
    class = "toast.ops.scan_wcs.ScanWCSMap"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key for accumulating output
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    file = "None" # Path to FITS file
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "scan_wcs_map" # The 'name' of this class instance
    pixel_dist = "pixel_dist" # The Data key where the PixelDistribution object is located
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator
    save_map = false # If True, do not delete map during finalize
    save_pointing = false # If True, do not clear detector pointing matrices if we generate the pixel distribution
    stokes_weights = "None" # This must be an instance of a Stokes weights operator
    subtract = false # If True, subtract the map timestream instead of accumulating
    zero = false # If True, zero the data before accumulating / subtracting

[operators.scan_wcs_map_weights]
    class = "toast.ops.stokes_weights.stokes_weights.StokesWeights"
    API = 0 # Internal interface version for this operator
    IAU = false # If True, use the IAU convention rather than COSMO
    cal = "None" # The observation key with a dictionary of pointing weight calibration for each det
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    fp_gamma = "gamma" # Focalplane key for detector gamma offset angle
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    mode = "IQU" # The Stokes weights to generate (I or IQU)
    name = "scan_wcs_map_weights" # The 'name' of this class instance
    single_precision = false # If True, use 32bit float in output
    view = "None" # Use this view of the data in all observations
    weights = "weights_scan_map" # Observation detdata key for output weights

[operators.scan_wcs_map_pixels]
    class = "toast.ops.pixels_wcs.PixelsWCS"
    API = 0 # Internal interface version for this operator
    auto_bounds = true # If True, set the bounding box based on boresight and field of view
    bounds = "()" # The (lon_min, lon_max, lat_min, lat_max) values (Quantities)
    center = "()" # The center Lon/Lat coordinates (Quantities) of the projection
    center_offset = "None" # Optional name of shared field with lon, lat offset in degrees
    coord_frame = "EQU" # Supported values are AZEL, EQU, GAL, ECL
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dimensions = "(1000,1000,)" # The Lon/Lat pixel dimensions of the projection
    enabled = false # If True, this class instance is marked as enabled
    fits_header = "None" # FITS file containing header to use with pre-existing WCS parameters
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "scan_wcs_map_pixels" # The 'name' of this class instance
    pixels = "pixels_scan_map" # Observation detdata key for output pixel indices
    projection = "CAR" # Supported values are CAR, CEA, MER, ZEA, TAN, SFL
    resolution = "(Quantity('5.00000000000000e-03 deg'),Quantity('5.00000000000000e-03 deg'),)" # The Lon/Lat projection resolution (Quantities) along the 2 axes
    single_precision = false # If True, use 32bit int in output
    submaps = 1 # Number of submaps to use
    use_astropy = true # If True, use astropy for world to pix conversion
    view = "None" # Use this view of the data in all observations

[operators.conviqt]
    class = "toast.ops.conviqt.SimConviqt"
    API = 0 # Internal interface version for this operator
    apply_flags = false # Only synthesize signal for unflagged samples.
    beam_file = "None" # File containing the beam a_lm expansion.  Tag {detector} will be replaced with the detector name.
    beam_file_dict = "{}" # Dictionary of files containing the beam a_lm expansions. An entry for each detector name must be present. If provided, supersedes `beam_file`.
    beammmax = -1 # Beam maximum m.  Actual resolution in the Healpix FITS file may differ. If not set, will use the maximum expansion order from file.
    calibrate = true # Calibrate intensity to 1.0, rather than (1 + epsilon) / 2. Calibrate has no effect if the beam is found to be normalized rather than scaled with the leakage factor.
    comm = "None" # MPI communicator to use for the convolution. libConviqt does not work without MPI.
    det_data = "signal" # Observation detdata key for accumulating convolved timestreams
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dxx = true # The beam frame is either Dxx or Pxx. Pxx includes the rotation to polarization sensitive basis, Dxx does not. When Dxx=True, detector orientation from attitude quaternions is corrected for the polarization angle.
    enabled = false # If True, this class instance is marked as enabled
    fwhm = "Quantity('4.00000000000000e+00 arcmin')" # Width of a symmetric gaussian beam already present in the skyfile (will be deconvolved away).
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lmax = -1 # Maximum ell (and m).  Actual resolution in the Healpix FITS file may differ.  If not set, will use the maximum expansion order from file.
    mc = "None" # Monte Carlo index used in synthesizing the input file names.
    name = "conviqt" # The 'name' of this class instance
    normalize_beam = false # Normalize beam to have unit response to temperature monopole.
    order = 13 # Conviqt order parameter (expert mode)
    pol = true # Toggle simulated signal polarization
    remove_dipole = false # Suppress the temperature dipole in sky_file.
    remove_monopole = false # Suppress the temperature monopole in sky_file.
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    sky_file = "None" # File containing the sky a_lm expansion.  Tag {detector} will be replaced with the detector name
    sky_file_dict = "{}" # Dictionary of files containing the sky a_lm expansions. An entry for each detector name must be present. If provided, supersedes `sky_file`.
    verbosity = 0 # 
    view = "None" # Use this view of the data in all observations

[operators.conviqt_teb]
    class = "toast.ops.conviqt.SimTEBConviqt"
    API = 0 # Internal interface version for this operator
    apply_flags = false # Only synthesize signal for unflagged samples.
    beam_file = "None" # File containing the beam a_lm expansion.  Tag {detector} will be replaced with the detector name.
    beam_file_dict = "{}" # Dictionary of files containing the beam a_lm expansions. An entry for each detector name must be present. If provided, supersedes `beam_file`.
    beammmax = -1 # Beam maximum m.  Actual resolution in the Healpix FITS file may differ. If not set, will use the maximum expansion order from file.
    calibrate = true # Calibrate intensity to 1.0, rather than (1 + epsilon) / 2. Calibrate has no effect if the beam is found to be normalized rather than scaled with the leakage factor.
    comm = "None" # MPI communicator to use for the convolution. libConviqt does not work without MPI.
    det_data = "signal" # Observation detdata key for accumulating convolved timestreams
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dxx = true # The beam frame is either Dxx or Pxx. Pxx includes the rotation to polarization sensitive basis, Dxx does not. When Dxx=True, detector orientation from attitude quaternions is corrected for the polarization angle.
    enabled = false # If True, this class instance is marked as enabled
    fwhm = "Quantity('4.00000000000000e+00 arcmin')" # Width of a symmetric gaussian beam already present in the skyfile (will be deconvolved away).
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lmax = -1 # Maximum ell (and m).  Actual resolution in the Healpix FITS file may differ.  If not set, will use the maximum expansion order from file.
    mc = "None" # Monte Carlo index used in synthesizing the input file names.
    name = "conviqt_teb" # The 'name' of this class instance
    normalize_beam = false # Normalize beam to have unit response to temperature monopole.
    order = 13 # Conviqt order parameter (expert mode)
    pol = true # Toggle simulated signal polarization
    remove_dipole = false # Suppress the temperature dipole in sky_file.
    remove_monopole = false # Suppress the temperature monopole in sky_file.
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    sky_file = "None" # File containing the sky a_lm expansion.  Tag {detector} will be replaced with the detector name
    sky_file_dict = "{}" # Dictionary of files containing the sky a_lm expansions. An entry for each detector name must be present. If provided, supersedes `sky_file`.
    verbosity = 0 # 
    view = "None" # Use this view of the data in all observations

[operators.sim_noise]
    class = "toast.ops.sim_tod_noise.SimNoise"
    API = 0 # Internal interface version for this operator
    component = 0 # The noise component index
    det_data = "signal" # Observation detdata key for accumulating noise timestreams
    det_data_units = "Unit('K')" # Output units if creating detector data
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "sim_noise" # The 'name' of this class instance
    noise_model = "noise_model" # Observation key containing the noise model
    realization = 0 # The noise realization index
    serial = true # Use legacy serial implementation instead of batched
    times = "times" # Observation shared key for timestamps

[operators.gainscrambler]
    class = "toast.ops.gainscrambler.GainScrambler"
    API = 0 # Internal interface version for this operator
    component = 0 # Component index for this simulation
    constant = false # If True, scramble all detector pairs in the same way
    det_data_names = "['signal',]" # Observation detdata key(s) to apply the gain error to
    dist = "gaussian" # Gain distribution density
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    location = 1.0 # Distribution location parameter
    name = "gainscrambler" # The 'name' of this class instance
    pattern = ".*" # Regex pattern to match against detector names. Only detectors that match the pattern are scrambled.
    process_pairs = false # Process detectors in pairs
    realization = 0 # Realization index
    scale = 0.001 # Distribution scale parameter
    store = false # Store the scrambled values

[operators.save_hdf5]
    class = "toast.ops.save_hdf5.SaveHDF5"
    API = 0 # Internal interface version for this operator
    compress_detdata = false # If True, use FLAC to compress detector signal
    compress_precision = "None" # Number of significant digits to retain in detdata compression
    config = "{}" # Write this job config to the file
    detdata = "[]" # Only save this list of detdata objects
    detdata_float32 = false # If True, convert any float64 detector data to float32 on write.
    detdata_in_place = false # If True, all compressed detector data will be decompressed and written over the input data.
    enabled = false # If True, this class instance is marked as enabled
    force_serial = false # Use serial HDF5 operations, even if parallel support available
    intervals = "[]" # Only save this list of intervals objects
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    meta = "[]" # Only save this list of meta objects
    name = "save_hdf5" # The 'name' of this class instance
    shared = "[]" # Only save this list of shared objects
    times = "times" # Observation shared key for timestamps
    verify = false # If True, immediately load data back in and verify
    volume = "toast_out_hdf5" # Top-level directory for the data volume

[operators.noise_cut]
    class = "toast.ops.noise_estimation.NoiseEstim"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key apply filtering to
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame.  Only relevant if `maskfile` and/or `mapfile` are set
    enabled = false # If True, this class instance is marked as enabled
    focalplane_key = "None" # When set, PSDs are measured over averaged TODs
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lagmax = 1024 # Maximum lag to consider for the covariance function. Will be truncated the length of the longest view.
    mapfile = "None" # Optional HEALPix map to sample and subtract from the signal
    mask_flag_mask = 2 # Bit mask for raising processing mask flags
    mask_flags = "flags" # Observation detdata key for processing mask flags
    maskfile = "None" # Optional HEALPix processing mask
    name = "noise_cut" # The 'name' of this class instance
    naverage = 64 # Smoothing kernel width for downsampled data
    nbin_psd = 64 # Bin the resulting PSD
    nocross = true # Do not evaluate cross-PSDs.  Overridden by `pairs`
    nosingle = false # Do not evaluate individual PSDs.  Overridden by `pairs`
    nsum = 1 # Downsampling factor for decimated data
    out_model = "noise_cut" # Create a new noise model with this name
    output_dir = "None" # If specified, write output data products to this directory
    pairs = "[]" # Detector pairs to estimate noise for.  Overrides `nosingle` and `nocross`
    pixel_dist = "pixel_dist" # The Data key where the PixelDistribution object is located.  Only relevant if `maskfile` and/or `mapfile` are set
    pixel_pointing = "None" # An instance of a pixel pointing operator.  Only relevant if `maskfile` and/or `mapfile` are set
    pol = true # Sample also the polarized part of the map
    remove_common_mode = false # Remove common mode signal before estimation
    save_cov = false # Save also the sample covariance
    shared_flag_mask = 15 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    stationary_period = "Quantity('8.64000000000000e+04 s')" # Break the observation into several estimation periods of this length
    stokes_weights = "None" # An instance of a Stokes weights operator.  Only relevant if `mapfile` is set
    symmetric = false # If True, treat positive and negative lags as equivalent in the cross correlator
    times = "times" # Observation shared key for timestamps
    view = "None" # Only measure the covariance within each view

[operators.noise_cut_fit]
    class = "toast.ops.noise_model.FitNoiseModel"
    API = 0 # Internal interface version for this operator
    bad_fit_mask = 2 # Bit mask to raise for bad fits
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    f_min = "Quantity('1.00000000000000e-05 Hz')" # Low-frequency rolloff of model in the fit
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    least_squares_ftol = 1e-10 # The ftol value passed to the least_squares solver
    least_squares_gtol = "None" # The gtol value passed to the least_squares solver
    least_squares_xtol = "None" # The xtol value passed to the least_squares solver
    name = "noise_cut_fit" # The 'name' of this class instance
    noise_model = "noise_model" # The observation key containing the input noise model
    out_model = "noise_cut_fit" # Create a new noise model with this name
    white_noise_max = "None" # The maximum frequency to consider for the white noise plateau
    white_noise_min = "None" # The minimum frequency to consider for the white noise plateau

[operators.noise_cut_flag]
    class = "toast.ops.noise_model.FlagNoiseFit"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key for timestreams (only if RMS cut enabled)
    det_flag_mask = 1 # Bit mask value for detector sample flagging (only if RMS cut used)
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "noise_cut_flag" # The 'name' of this class instance
    noise_model = "noise_model" # The observation key containing the noise model
    outlier_flag_mask = 2 # Bit mask to raise flags with
    sigma_NET = 5.0 # Flag detectors with NET values outside this range
    sigma_fknee = 5.0 # Flag detectors with knee frequency values outside this range
    sigma_rms = "None" # In addition to flagging based on estimated model, also apply overall TOD cut

[operators.noise_estim]
    class = "toast.ops.noise_estimation.NoiseEstim"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key apply filtering to
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame.  Only relevant if `maskfile` and/or `mapfile` are set
    enabled = false # If True, this class instance is marked as enabled
    focalplane_key = "None" # When set, PSDs are measured over averaged TODs
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lagmax = 1024 # Maximum lag to consider for the covariance function. Will be truncated the length of the longest view.
    mapfile = "None" # Optional HEALPix map to sample and subtract from the signal
    mask_flag_mask = 2 # Bit mask for raising processing mask flags
    mask_flags = "flags" # Observation detdata key for processing mask flags
    maskfile = "None" # Optional HEALPix processing mask
    name = "noise_estim" # The 'name' of this class instance
    naverage = 64 # Smoothing kernel width for downsampled data
    nbin_psd = 64 # Bin the resulting PSD
    nocross = true # Do not evaluate cross-PSDs.  Overridden by `pairs`
    nosingle = false # Do not evaluate individual PSDs.  Overridden by `pairs`
    nsum = 1 # Downsampling factor for decimated data
    out_model = "noise_estim" # Create a new noise model with this name
    output_dir = "None" # If specified, write output data products to this directory
    pairs = "[]" # Detector pairs to estimate noise for.  Overrides `nosingle` and `nocross`
    pixel_dist = "pixel_dist" # The Data key where the PixelDistribution object is located.  Only relevant if `maskfile` and/or `mapfile` are set
    pixel_pointing = "None" # An instance of a pixel pointing operator.  Only relevant if `maskfile` and/or `mapfile` are set
    pol = true # Sample also the polarized part of the map
    remove_common_mode = false # Remove common mode signal before estimation
    save_cov = false # Save also the sample covariance
    shared_flag_mask = 15 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    stationary_period = "Quantity('8.64000000000000e+04 s')" # Break the observation into several estimation periods of this length
    stokes_weights = "None" # An instance of a Stokes weights operator.  Only relevant if `mapfile` is set
    symmetric = false # If True, treat positive and negative lags as equivalent in the cross correlator
    times = "times" # Observation shared key for timestamps
    view = "None" # Only measure the covariance within each view

[operators.noise_estim_fit]
    class = "toast.ops.noise_model.FitNoiseModel"
    API = 0 # Internal interface version for this operator
    bad_fit_mask = 2 # Bit mask to raise for bad fits
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    f_min = "Quantity('1.00000000000000e-05 Hz')" # Low-frequency rolloff of model in the fit
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    least_squares_ftol = 1e-10 # The ftol value passed to the least_squares solver
    least_squares_gtol = "None" # The gtol value passed to the least_squares solver
    least_squares_xtol = "None" # The xtol value passed to the least_squares solver
    name = "noise_estim_fit" # The 'name' of this class instance
    noise_model = "noise_model" # The observation key containing the input noise model
    out_model = "noise_estim_fit" # Create a new noise model with this name
    white_noise_max = "None" # The maximum frequency to consider for the white noise plateau
    white_noise_min = "None" # The minimum frequency to consider for the white noise plateau

[operators.raw_statistics]
    class = "toast.ops.statistics.Statistics"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key to analyze
    det_flag_mask = 7 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 7 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "raw_statistics" # The 'name' of this class instance
    output_dir = "None" # If specified, write output data products to this directory
    shared_flag_mask = 15 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    view = "None" # Use this view of the data in all observations

[operators.binner]
    class = "toast.ops.mapmaker_binning.BinMap"
    API = 0 # Internal interface version for this operator
    binned = "binned" # The Data key where the binned map should be stored
    covariance = "covariance" # The Data key containing the noise covariance PixelData instance
    det_data = "signal" # Observation detdata key for the timestream data
    det_data_units = "Unit('K')" # Desired timestream units
    det_flag_mask = 7 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 7 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    full_pointing = false # If True, expand pointing for all detectors and save
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "binner" # The 'name' of this class instance
    noise_model = "noise_model" # Observation key containing the noise model
    noiseweighted = "None" # The Data key where the noiseweighted map should be stored
    pixel_dist = "pix_dist" # The Data key where the PixelDist object should be stored
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator
    pre_process = "None" # Optional extra operator to run prior to binning
    shared_flag_mask = 15 # Bit mask value for optional telescope flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    stokes_weights = "None" # This must be an instance of a Stokes weights operator
    sync_type = "alltoallv" # Communication algorithm: 'allreduce' or 'alltoallv'

[operators.binner_final]
    class = "toast.ops.mapmaker_binning.BinMap"
    API = 0 # Internal interface version for this operator
    binned = "binned" # The Data key where the binned map should be stored
    covariance = "covariance" # The Data key containing the noise covariance PixelData instance
    det_data = "signal" # Observation detdata key for the timestream data
    det_data_units = "Unit('K')" # Desired timestream units
    det_flag_mask = 7 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 7 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    full_pointing = false # If True, expand pointing for all detectors and save
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "binner_final" # The 'name' of this class instance
    noise_model = "noise_model" # Observation key containing the noise model
    noiseweighted = "None" # The Data key where the noiseweighted map should be stored
    pixel_dist = "pix_dist_final" # The Data key where the PixelDist object should be stored
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator
    pre_process = "None" # Optional extra operator to run prior to binning
    shared_flag_mask = 15 # Bit mask value for optional telescope flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    stokes_weights = "None" # This must be an instance of a Stokes weights operator
    sync_type = "alltoallv" # Communication algorithm: 'allreduce' or 'alltoallv'

[operators.mapmaker]
    class = "toast.ops.mapmaker.MapMaker"
    API = 0 # Internal interface version for this operator
    binning = "None" # Binning operator used for solving template amplitudes
    convergence = 1e-12 # Relative convergence limit
    det_data = "signal" # Observation detdata key for the timestream data
    enabled = true # If True, this class instance is marked as enabled
    iter_max = 100 # Maximum number of iterations
    iter_min = 3 # Minimum number of iterations
    keep_final_products = false # If True, keep the map domain products in data after write
    keep_solver_products = false # If True, keep the map domain solver products in data
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    map_binning = "None" # Binning operator for final map making.  Default is same as solver
    map_rcond_threshold = 1e-08 # For final map, minimum value for inverse pixel condition number cut.
    mask = "None" # Data key for pixel mask to use in solving.  First bit of pixel values is tested
    mc_index = "None" # The Monte-Carlo index
    mc_mode = false # If True, re-use solver flags, sparse covariances, etc
    name = "mapmaker" # The 'name' of this class instance
    output_dir = "." # Write output data products to this directory
    overwrite_cleaned = false # If True and save_cleaned is True, overwrite the input data
    report_memory = false # Report memory throughout the execution
    reset_pix_dist = false # Clear any existing pixel distribution.  Useful when applying repeatedly to different data objects.
    save_cleaned = false # If True, save the template-subtracted detector timestreams
    solve_rcond_threshold = 1e-08 # When solving, minimum value for inverse pixel condition number cut.
    template_matrix = "None" # This must be an instance of a template matrix operator
    write_binmap = true # If True, write the projected map *before* template subtraction
    write_cov = true # If True, write the white noise covariance matrices.
    write_hdf5 = false # If True, outputs are in HDF5 rather than FITS format.
    write_hdf5_serial = false # If True, force serial HDF5 write of output maps.
    write_hits = true # If True, write the hits map
    write_invcov = false # If True, write the inverse white noise covariance matrices.
    write_map = true # If True, write the projected map
    write_noiseweighted_map = false # If True, write the noise-weighted map
    write_rcond = true # If True, write the reciprocal condition numbers.
    write_solver_products = false # If True, write out equivalent solver products.

[operators.mappraiser]
    class = "pymappraiser.toast.mappraiser.Mappraiser"
    API = 0 # Internal interface version for this operator
    apod_window_type = "chebwin" # Type of apodisation window to use during noise PSD estimation
    az_name = "azimuth" # Observation boresight azimuth key
    bandwidth = 16384 # Half-bandwidth for the noise model
    bs_red = 0 # Use dynamic search reduction
    copy_groups = 1 # The processes on each node are split into this number of groups to copy data in turns
    det_data = "signal" # Observation detdata key for the timestream data
    det_flag_mask = 7 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 7 # Bit mask value for per-detector flagging
    do_gap_filling = true # Perform gap filling on the data
    downscale = 1 # Scale down the noise by the sqrt of this number to artifically increase S/N ratio
    enabled = false # If True, this class instance is marked as enabled
    enlFac = 1 # Enlargement factor for ECG
    estimate_spin_zero = false # When doing pair-diff, still estimate a spin-zero field (T) alongside Q and U.
    fill_noise_zero = false # Fill the noise vector with zeros just before calling Mappraiser
    fixed_polybase = 0 # Flag to set a specific polynomial baseline length. When False the baseline length is set to the sweep duration (ground only).
    gap_stgy = 0 # Strategy for handling timestream gaps
    hwpangle_name = "hwp_angle" # Observation hwp angle key
    hwpssbaseline_length = 10.0 # HWPSS baseline length in seconds (default = 10.0s)
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    map_maker = "ML" # Map-making approach: 'ML' for maximum likelihood (downweigthing approach), 'MT' for marginalized templates.
    maxiter = 3000 # Maximum number of iterations allowed for the solver
    mcmode = false # If true, Madam will store auxiliary information such as pixel matrices and noise filter
    mem_report = false # Print system memory use while staging/unstaging data
    name = "mappraiser" # The 'name' of this class instance
    nhwp = 0 # Order of HWPSS templates
    noise_model = "noise_model" # Observation key containing the noise model
    noise_model_fit = "noise_estim_fit" # Observation key containing a noise model fitted to the data
    noise_name = "noise" # Observation detdata key for noise data (if None, triggers noiseless mode)
    noise_scale = "noise_scale" # Observation key with optional scaling factor for noise PSDs
    noiseless = false # Activate noiseless mode
    npoly = 0 # Order of polynomial templates
    ortho_alg = 1 # Orthogonalization scheme for ECG (O->odir, 1->omin)
    pair_diff = false # Process differenced timestreams between orthogonal detectors in pairs.
    paramfile = "None" # Read mappraiser parameters from this file
    params = "{}" # Parameters to pass to mappraiser
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator
    polybaseline_length = 10.0 # Polynomial baseline length in seconds (default = 10.0s)
    precond = 0 # Choose preconditioner (0->BJ, 1->2lvl a priori, 2->2lvl a posteriori)
    ptcomm_flag = 6 # Choose collective communication scheme
    purge_det_data = false # If True, clear all observation detector data after copying to mappraiser buffers
    realization = 0 # Noise realization index (for gap filling)
    restore_det_data = false # If True, restore detector data to observations on completion
    save_psd = false # Save noise PSD information during inv_tt computation
    sbins = 0 # Number of azimuth bins in the SSS template
    shared_flag_mask = 15 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    signal_fraction = 1.0 # Fraction of the sky signal to keep
    solver = 0 # Choose mapmaking solver (0->PCG, 1->ECG)
    sss = 0 # Scan Synchronous Signal template flag.
    stokes_weights = "None" # This must be an instance of a Stokes weights operator
    times = "times" # Observation shared key for timestamps
    tol = 1e-12 # Convergence threshold for the iterative solver
    translate_timestamps = false # Translate timestamps to enforce monotonicity
    uniform_w = 0 # Flag to use a uniform white noise model in reduction.
    use_noise_model = false # Use an existing noise model fitted to the data (`noise_model_fit` trait)
    view = "None" # Use this view of the data in all observations
    z_2lvl = 0 # Size of 2lvl deflation space

[operators.mem_count]
    class = "toast.ops.memory_counter.MemoryCounter"
    API = 0 # Internal interface version for this operator
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "mem_count" # The 'name' of this class instance
    prefix = "''" # Prefix for log messages
    silent = false # If True, return the memory used but do not log the result

[templates.baselines]
    class = "toast.templates.offset.offset.Offset"
    data = "None" # This must be an instance of a Data class (or None)
    debug_plots = "None" # If not None, make debugging plots in this directory
    det_data = "signal" # Observation detdata key for the timestream data
    det_data_units = "Unit('K')" # Desired units of detector data
    det_flag_mask = 7 # Bit mask value for solver flags
    det_flags = "flags" # Observation detdata key for solver flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    good_fraction = 0.5 # Fraction of unflagged samples needed to keep a given offset amplitude
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "baselines" # The 'name' of this class instance
    noise_model = "None" # Observation key containing the optional noise model
    precond_width = 20 # Preconditioner width in terms of offsets / baselines
    step_time = "Quantity('2.00000000000000e+00 s')" # Time per baseline step
    times = "times" # Observation shared key for timestamps
    use_noise_prior = false # Use detector PSDs to build the noise prior and preconditioner
    view = "None" # Use this view of the data in all observations

[templates.azss]
    class = "toast.templates.periodic.Periodic"
    bins = "None" # Number of bins between min / max values of data key
    data = "None" # This must be an instance of a Data class (or None)
    det_data = "signal" # Observation detdata key for the timestream data
    det_data_units = "Unit('K')" # Desired units of detector data
    det_flag_mask = 7 # Bit mask value for solver flags
    det_flags = "flags" # Observation detdata key for solver flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    flag_mask = 1 # Bit mask value for flags
    flags = "flags" # Observation data key for flags to use
    increment = 0.0174532925199433 # The increment of the data key for each bin
    is_detdata_key = false # If True, the periodic data and flags are detector fields, not shared
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    key = "azimuth" # Observation data key for the periodic quantity
    minimum_bin_hits = 3 # Minimum number of samples per amplitude bin
    name = "azss" # The 'name' of this class instance
    view = "None" # Use this view of the data in all observations

[templates.hwpss]
    class = "toast.templates.hwpss.Hwpss"
    data = "None" # This must be an instance of a Data class (or None)
    debug_plots = "None" # If not None, make debugging plots in this directory
    det_data = "signal" # Observation detdata key for the timestream data
    det_data_units = "Unit('K')" # Desired units of detector data
    det_flag_mask = 7 # Bit mask value for solver flags
    det_flags = "flags" # Observation detdata key for solver flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    harmonics = 5 # Number of harmonics to consider in the expansion
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    hwp_flag_mask = 1 # Bit mask to use when considering valid HWP angle values.
    hwp_flags = "flags" # Observation shared key for HWP flags
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "hwpss" # The 'name' of this class instance
    times = "times" # Observation shared key for timestamps
    view = "None" # Use this view of the data in all observations

[templates.fourier2d]
    class = "toast.templates.fourier2d.Fourier2D"
    correlation_amplitude = 10.0 # Scale factor of the filter
    correlation_length = "Quantity('5.00000000000000e+00 s')" # Correlation length in time
    data = "None" # This must be an instance of a Data class (or None)
    debug_plots = "None" # If not None, make debugging plots in this directory
    det_data = "signal" # Observation detdata key for the timestream data
    det_data_units = "Unit('K')" # Desired units of detector data
    det_flag_mask = 7 # Bit mask value for solver flags
    det_flags = "flags" # Observation detdata key for solver flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    fit_subharmonics = false # If True, fit subharmonics
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "fourier2d" # The 'name' of this class instance
    noise_model = "None" # Observation key containing the optional noise model
    order = 1 # The filter order
    times = "times" # Observation shared key for timestamps
    view = "None" # Use this view of the data in all observations
